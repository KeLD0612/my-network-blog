<!doctype html><html lang=vi><head><meta charset=UTF-8><title>Kiến trúc Client – Server trong Java: Cơ chế và hoạt động chi tiết</title><link rel=stylesheet href=../../css/style.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><header><nav class=nav><h1 class=logo>D | Network Dev</h1><ul><li><a href=../../>Home</a></li><li><a href=../../blog/>Blog</a></li><li><a href=../../profile/>Profile</a></li></ul></nav></header><main class=container><article class=post-detail><h1 class=post-title>Kiến trúc Client – Server trong Java: Cơ chế và hoạt động chi tiết</h1><p class=post-meta>02/01/2025</p><img class=post-cover src=../../images/client-server-in-java.jpg alt><div class=post-content><h2 id=kiến-trúc-client--server-trong-java>Kiến trúc Client – Server trong Java</h2><p>Mô hình <strong>Client – Server (Khách – Chủ)</strong> là xương sống của hầu hết
các ứng dụng mạng hiện đại.<br>Trong Java, mô hình này được hiện thực hóa mạnh mẽ thông qua gói
<strong><code>java.net</code></strong>, chủ yếu sử dụng giao thức <strong>TCP</strong>
để đảm bảo độ tin cậy của dữ liệu truyền tải.</p><hr><h2 id=1-quy-trình-hoạt-động-workflow>1. Quy trình hoạt động (Workflow)</h2><p>Quy trình giao tiếp giữa Client và Server trong Java
diễn ra theo các bước tuần tự và chặt chẽ:</p><h3 id=11-khởi-tạo-server-binding>1.1 Khởi tạo Server (Binding)</h3><p>Server sử dụng lớp <code>ServerSocket</code> để đăng ký một cổng (<em>port</em>)
cụ thể trên máy chủ (ví dụ: <strong>port 8080</strong>).</p><h3 id=12-lắng-nghe-kết-nối-listening>1.2 Lắng nghe kết nối (Listening)</h3><p>Server gọi phương thức <code>accept()</code>.</p><ul><li>Đây là phương thức <strong>blocking</strong></li><li>Chương trình server sẽ tạm dừng tại đây</li><li>Chỉ tiếp tục khi có client kết nối tới</li></ul><h3 id=13-client-gửi-yêu-cầu-kết-nối>1.3 Client gửi yêu cầu kết nối</h3><p>Client khởi tạo đối tượng <code>Socket</code>
kèm theo địa chỉ IP và port của Server
để gửi yêu cầu <strong>handshake</strong>.</p><h3 id=14-thiết-lập-liên-kết>1.4 Thiết lập liên kết</h3><p>Khi Server chấp nhận yêu cầu:</p><ul><li>Một <strong>kênh giao tiếp ảo (Virtual Circuit)</strong> được thiết lập</li><li><code>accept()</code> trả về một đối tượng <code>Socket</code> mới</li><li>Socket này dùng riêng cho client đó</li></ul><h3 id=15-trao-đổi-dữ-liệu-io-operations>1.5 Trao đổi dữ liệu (I/O Operations)</h3><p>Hai phía giao tiếp thông qua:</p><ul><li><code>InputStream</code> – nhận dữ liệu</li><li><code>OutputStream</code> – gửi dữ liệu</li></ul><p>Dữ liệu được truyền dưới dạng byte hoặc ký tự.</p><hr><h2 id=2-chiến-lược-xử-lý-đa-luồng-multi-threading-strategy>2. Chiến lược xử lý đa luồng (Multi-threading Strategy)</h2><p>Đây là yếu tố <strong>then chốt</strong> giúp Server phục vụ nhiều Client
mà không bị “đơ”.</p><h3 id=21-vấn-đề>2.1 Vấn đề</h3><p>Nếu Server chỉ chạy trên <strong>một luồng chính (Main Thread)</strong>:</p><ul><li>Chỉ phục vụ được <strong>1 Client tại một thời điểm</strong></li><li>Client tiếp theo phải chờ kết nối trước kết thúc</li></ul><h3 id=22-giải-pháp-trong-java>2.2 Giải pháp trong Java</h3><p>Java giải quyết vấn đề này bằng <strong>đa luồng</strong>:</p><ul><li>Khi <code>accept()</code> trả về một <code>Socket</code> mới:<ul><li>Server tạo một <strong>Thread</strong> mới (hoặc lấy từ Thread Pool)</li></ul></li><li>Thread này chịu trách nhiệm giao tiếp riêng với Client</li><li>Luồng chính quay lại trạng thái <code>accept()</code> ngay lập tức</li></ul><h3 id=23-lưu-ý-kỹ-thuật>2.3 Lưu ý kỹ thuật</h3><p>Trong các hệ thống hiện đại:</p><ul><li>❌ Không nên tạo <code>new Thread()</code> cho mỗi kết nối</li><li>✅ Nên dùng <strong><code>ExecutorService</code> (Thread Pool)</strong></li></ul><p>Ưu điểm:</p><ul><li>Quản lý luồng hiệu quả</li><li>Tránh quá tải bộ nhớ</li><li>Tăng khả năng mở rộng (scalability)</li></ul><hr><h2 id=3-các-thành-phần-code-cốt-lõi>3. Các thành phần code cốt lõi</h2><table><thead><tr><th>Thành phần</th><th>Lớp Java</th><th>Vai trò</th></tr></thead><tbody><tr><td>Server Listener</td><td><code>ServerSocket(port)</code></td><td>“Cánh cổng” đón Client, chỉ cần một đối tượng</td></tr><tr><td>Communication Endpoint</td><td><code>Socket(ip, port)</code></td><td>Kênh giao tiếp giữa Client và Server</td></tr><tr><td>Dòng dữ liệu vào</td><td><code>InputStream</code></td><td>Nhận dữ liệu từ phía bên kia</td></tr><tr><td>Dòng dữ liệu ra</td><td><code>OutputStream</code></td><td>Gửi dữ liệu đến phía bên kia</td></tr></tbody></table><hr><h2 id=4-ứng-dụng-thực-tế>4. Ứng dụng thực tế</h2><p>Kiến trúc Client – Server trong Java
là nền tảng của rất nhiều hệ thống thực tế:</p><ul><li><p><strong>Web Server</strong> (Tomcat, Jetty)<br>Xử lý hàng nghìn yêu cầu HTTP từ trình duyệt</p></li><li><p><strong>Database Server</strong><br>Kết nối JDBC tới MySQL, PostgreSQL thực chất là Socket</p></li><li><p><strong>Game Online</strong><br>Đồng bộ trạng thái nhân vật trong thời gian thực</p></li><li><p><strong>Remote Desktop</strong><br>Điều khiển máy tính từ xa qua mạng</p></li></ul><hr><h2 id=kết-luận>Kết luận</h2><p>Kiến trúc Client – Server trong Java
là nền tảng quan trọng để xây dựng
các hệ thống mạng ổn định, an toàn và mở rộng tốt.
Việc hiểu rõ cơ chế hoạt động và chiến lược đa luồng
giúp lập trình viên thiết kế Server hiệu quả ngay từ đầu.</p></div></article></main><footer><p>© 2025 - Blog cá nhân về Lập trình Mạng | Hugo + GitHub Pages</p></footer></body></html>