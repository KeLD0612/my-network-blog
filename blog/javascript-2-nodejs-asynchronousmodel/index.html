<!doctype html><html lang=vi><head><meta charset=UTF-8><title>Node.js và mô hình bất đồng bộ</title><link rel=stylesheet href=../../css/style.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><header><nav class=nav><h1 class=logo>D | Network Dev</h1><ul><li><a href=../../>Home</a></li><li><a href=../../blog/>Blog</a></li><li><a href=../../profile/>Profile</a></li></ul></nav></header><main class=container><article class=post-detail><h1 class=post-title>Node.js và mô hình bất đồng bộ</h1><p class=post-meta>05/01/2025</p><img class=post-cover src=../../images/Nodejs-asynchronousModel.jpg alt><div class=post-content><p>Khi mới chuyển từ các ngôn ngữ server-side truyền thống như PHP hay Java sang Node.js, điều khiến tôi bối rối nhất không phải là cú pháp JavaScript (vì nó quá quen thuộc ở frontend), mà chính là tư duy &ldquo;Bất đồng bộ&rdquo; (Asynchronous).</p><p>Node.js không đơn thuần là đem JavaScript lên server chạy. Nó là một môi trường runtime được xây dựng trên nền tảng V8 engine cực mạnh của Google, nhưng &ldquo;vũ khí bí mật&rdquo; giúp nó xử lý hàng nghìn kết nối đồng thời lại nằm ở kiến trúc đơn luồng (Single-threaded) kết hợp với Event Loop.</p><p>Hôm nay, hãy cùng tôi mổ xẻ xem mô hình này hoạt động như thế nào và tại sao nó lại thay đổi cách chúng ta xây dựng các ứng dụng mạng.</p><h2 id=câu-chuyện-về-người-phục-vụ-the-waiter-analogy>Câu chuyện về &ldquo;Người phục vụ&rdquo; (The Waiter Analogy)</h2><p>Để hiểu rõ nhất về sự khác biệt giữa mô hình truyền thống (Blocking) và Node.js (Non-blocking), tôi thường dùng ví dụ về một quán cà phê.</p><p><strong>Mô hình truyền thống (Multi-threaded/Blocking):</strong>
Hãy tưởng tượng một quán cà phê mà mỗi khi có khách bước vào, quán phải thuê riêng một nhân viên phục vụ để chăm sóc khách đó từ A-Z. Nhân viên này order, đứng chờ pha chế làm xong, rồi bưng ra, rồi chờ khách thanh toán. Trong lúc chờ pha chế, nhân viên này đứng chơi và không làm gì cả. Nếu có 100 khách, quán cần 100 nhân viên. Đây là cách các server truyền thống tạo ra một Thread mới cho mỗi request. Tài nguyên bị lãng phí rất lớn cho việc chờ đợi (I/O blocking).</p><p><strong>Mô hình Node.js (Single-threaded/Non-blocking):</strong>
Quán chỉ có <strong>một</strong> nhân viên phục vụ duy nhất tại quầy (đây chính là Main Thread).</p><ol><li>Khách A vào order. Nhân viên ghi nhận, chuyển phiếu xuống bếp (System Kernel/Worker Pool), và ngay lập tức quay sang hỏi khách B: &ldquo;Anh dùng gì ạ?&rdquo;.</li><li>Khách B order. Nhân viên lại chuyển phiếu xuống bếp, rồi quay sang khách C.</li><li>Khi bếp làm xong đồ uống của khách A, bếp bấm chuông (Callback/Event). Nhân viên phục vụ lúc này mới quay lại bưng đồ cho khách A.</li></ol><p>Nhân viên phục vụ không bao giờ đứng chơi. Đó chính là cách Node.js hoạt động: Không bao giờ chặn luồng chính (Don&rsquo;t block the Event Loop).</p><h2 id=event-loop-trái-tim-của-nodejs>Event Loop: Trái tim của Node.js</h2><p>Về mặt kỹ thuật, Node.js sử dụng cơ chế <strong>Event Loop</strong> để điều phối các tác vụ.</p><p>Khi có một yêu cầu nặng về I/O (như đọc file, truy vấn Database, gọi API bên thứ 3), Node.js sẽ không tự xử lý ngay tại luồng chính. Nó sẽ đẩy tác vụ đó xuống hệ thống (C++ APIs, libuv) để xử lý ngầm. Luồng chính tiếp tục nhận các yêu cầu khác.</p><p>Khi tác vụ ngầm hoàn tất, kết quả sẽ được đẩy vào một hàng đợi (Callback Queue). Event Loop có nhiệm vụ liên tục kiểm tra: &ldquo;Luồng chính có đang rảnh không?&rdquo;. Nếu rảnh, nó sẽ lấy kết quả từ hàng đợi đưa lên để thực thi callback.</p><p>Đây là ví dụ minh họa bằng code để thấy sự khác biệt:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;fs&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Cách viết Blocking (Đồng bộ) - Ít dùng trong Node.js
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Dòng code phía sau phải chờ dòng này chạy xong
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFileSync</span>(<span style=color:#e6db74>&#39;/file.md&#39;</span>); 
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Dòng này chỉ chạy sau khi đọc file xong&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Cách viết Non-blocking (Bất đồng bộ) - Chuẩn Node.js
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#39;/file.md&#39;</span>, (<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>err</span>) <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>err</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>); <span style=color:#75715e>// Chạy sau cùng khi file đọc xong
</span></span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Dòng này sẽ chạy NGAY LẬP TỨC, không cần chờ đọc file&#39;</span>);
</span></span></code></pre></div><h2 id=tại-sao-mô-hình-này-lại-phù-hợp-cho-ứng-dụng-mạng-lớn>Tại sao mô hình này lại phù hợp cho ứng dụng mạng lớn?</h2><p>Trong quá trình phát triển các dự án thực tế, tôi nhận thấy Node.js tỏa sáng rực rỡ nhất ở các tác vụ I/O Bound (thiên về nhập xuất dữ liệu).</p><ul><li><p>Tiết kiệm tài nguyên: Vì không phải tạo hàng nghìn thread cho hàng nghìn user, Node.js tiêu tốn rất ít RAM.</p></li><li><p>Tốc độ phản hồi cao: Ứng dụng không bị &ldquo;treo&rdquo; khi chờ dữ liệu từ database.</p></li><li><p>Realtime: Với các ứng dụng chat, thông báo, hay dashboard chứng khoán, việc duy trì kết nối liên tục (thông qua WebSocket) trên Node.js nhẹ nhàng hơn rất nhiều so với các nền tảng khác.</p></li></ul><p><strong>Khi nào không nên dùng?</strong>
Tuy nhiên, &ldquo;không có viên đạn bạc&rdquo;. Kinh nghiệm xương máu của tôi là đừng dùng Node.js cho các tác vụ tính toán nặng (CPU Bound).</p><p>Ví dụ: Xử lý nén video, tính toán ma trận phức tạp. Vì Node.js chỉ có một luồng chính, nếu bạn bắt nó tính toán quá lâu, nó sẽ bận rộn với phép tính đó và không thể nhận request từ các user khác (giống như nhân viên phục vụ bị kẹt lại giải toán cho khách A, và cả quán phải chờ).</p><hr><h2 id=kết-luận>Kết luận</h2><p>Hiểu sâu về mô hình bất đồng bộ và Event Loop là chìa khóa để làm chủ Node.js. Nó đòi hỏi chúng ta thay đổi tư duy lập trình tuần tự sang tư duy sự kiện (Event-driven). Một khi đã nắm bắt được nó, bạn sẽ thấy việc xây dựng các hệ thống API chịu tải cao trở nên thú vị và hiệu quả hơn bao giờ hết.</p></div></article></main><footer><p>© 2025 - Blog cá nhân về Lập trình Mạng | Hugo + GitHub Pages</p></footer></body></html>